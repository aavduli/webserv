
OVERVIEW:
- Separated parsing logic from data storage
- Clean layer separation with single responsibilities  
- Scalable design and separate testing possibilities

================================================================

1. DATA LAYER (Pure Data Structures)
   ├── HttpMessage (base data container)
   │   ├── State _state
   │   ├── double _http_version
   │   ├── map _headers
   │   └── string _body
   ├── HttpRequest (request data)
   │   ├── string _method
   │   └── string _uri
   └── HttpResponse (response data)
       ├── int _status_code
       └── string _reason_phrase

2. PARSING LAYER (String → Data Structures)
   ├── MessageParser (base parser with state machine)
   │   ├── State management
   │   ├── Raw data
   │   ├── Current position
   │   ├── content length
   │   └── Error handling
   ├── RequestParser (HttpRequest parsing)
   │   ├── parse_request_line()
   │   ├── parse_headers()
   │   └── parse_body()
   └── ResponseParser (HttpResponse parsing)
       ├── parse_status_line()
       ├── parse_headers()
       └── parse_body()

3. HANDLING LAYER (Data Structures → Business Logic)
   ├── RequestHandler (process requests)
   │   ├── validate_request()
   │   ├── process_request()
   │   └── generate_response()
   │   └── serialize_response()
   └── MessageValidator (validation logic)
       ├── validate_headers()
       ├── validate_method()
       └── validate_uri()

================================================================
INTERFACES BETWEEN LAYERS:

PARSING → DATA:
- Parser creates Data object
- Parser populates Data object
- Parser sets success/error state

DATA → HANDLING:
- Handler receives const Data object
- Handler validates Data object
- Handler creates response Data object

HANDLING → OUTPUT:
- Handler creates response
- Serializer converts to string
- Stream manager sends response

================================================================

MAIN PARSING TESTSOST

int	main(void) {

	std::vector<std::string>	test;
	console::setDebug(true);

	// test.push_back("GET / HTTP/1.0\r\n\r\n");	// simple OK
	// test.push_back("GET /path HTTP/1.1\r\nHost: example.com\r\nUser-Agent: \343\201\262\343/1.0\r\n\r\n");	// multibyte included
	// test.push_back("GET / HTTP/1.0\r\nfoo: \r\nfoo: b\r\n  \tc\r\n\r\n");	// multiline
	// test.push_back("GET / HTTP/1.0\r\nfoo : ab\r\n\r\n");	// trailing space in header OK
	// test.push_back("GET");	// incomplete KO
	// test.push_back("GET ");	// incomplete KO
	// test.push_back("GET /");	// incomplete KO
	// test.push_back("GET / ");	// incomplete KO
	// test.push_back("GET / H");	// incomplete KO
	// test.push_back("GET / HTTP/1.");	// incomplete KO
	// test.push_back("GET / HTTP/1.0");	// incomplete KO
	// test.push_back("GET / HTTP/1.0\r");	// incomplete KO
	// test.push_back(" / HTTP/1.0\r\n\r\n");	// empty method KO
	// test.push_back("GET  HTTP/1.0\r\n\r\n");	// empty path KO
	// test.push_back("GET / HTTP/1.0\r\n:a\r\n\r\n");	// empty header name KO
	// test.push_back("GET / HTTP/1.0\r\n :a\r\n\r\n");	// empty header value KO
	// test.push_back("G\0T / HTTP/1.0\r\n\r\n");	// NULL in method KO
	// test.push_back("G\tT / HTTP/1.0\r\n\r\n");	// tab in method KO
	// test.push_back(":GET / HTTP/1.0\r\n\r\n");	// invalid method KO
	// test.push_back("GET /\x7fhello HTTP/1.0\r\n\r\n");	// DEL in path TODO
	// test.push_back("GET / HTTP/1.0\r\na\0b: c\r\n\r\n");	// NULL in header name KO
	// test.push_back("GET / HTTP/1.0\r\nab: c\0d\r\n\r\n");	// NULL in header value KO
	// test.push_back("GET / HTTP/1.0\r\na\033b: c\r\n\r\n");	// CTL in header name TODO
	// test.push_back("GET / HTTP/1.0\r\nab: c\033\r\n\r\n");	// CTL in header value TODO
	// test.push_back("GET / HTTP/1.0\r\n/: 1\r\n\r\n");	// invalid char in header value TODO
	// test.push_back("GET /\xa0 HTTP/1.0\r\nh: c\xa2y\r\n\r\n");	// accept MSB char OK TODO
	// test.push_back("GET / HTTP/1.0\r\n\x7c\x7e: 1\r\n\r\n");	// accept ~ char OK TODO
	// test.push_back("GET / HTTP/1.0\r\n\x7b: 1\r\n\r\n");	// dont allow { OK TODO
	// test.push_back("GET / HTTP/1.0\r\nfoo: a \t \r\n\r\n");	// accept eading and trailing spaces in header value OK
	// test.push_back("GET   /   HTTP/1.0\r\n\r\n");	// accept multiple spaces between tokens OK

	RequestParser parser;

	for (size_t i = 0; i < test.size(); i++) {

		std::cout << YELLOW << "TEST [" << i << "]: " << test.at(i) << RESET;
		if (parser.is_complete_request(test.at(i))) {
			HttpRequest* request = parser.parse_request(test.at(i));
			if (parser.getState() == s_msg_done) {
				std::cout << GREEN << "SUCCESS" << RESET << std::endl;
			}
			else {
				std::cout << RED << "FAILURE " << parser.getState() << RESET << std::endl;
			}
			std::cout << std::endl;
			delete request;
		}
		else {
			std::cout << RED << " Incomplete request\n" << RESET << std::endl;
		}
	}
		
	return 0;
}